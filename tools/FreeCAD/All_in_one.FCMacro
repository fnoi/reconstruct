import os
import stat
import pickle
import json

import numpy as np
import math
from sys import platform

import Part
import Mesh
import Draft
import Arch

import importOBJ




def quaternion_rotation(v, ax=np.array([1.0, 0.0, 0.0])):
    v = v / norm(v)  # Normalize the vector

    if v[0] == 1.0:  # Vector is already aligned with x-axis
        q = np.array([1.0, 0.0, 0.0, 0.0])
    else:
        axis = np.cross(v, ax)  # Calculate rotation axis
        angle = np.arccos(np.dot(v, ax))  # Calculate rotation angle
        q = np.array([np.cos(angle/2), axis[0]*np.sin(angle/2), axis[1]*np.sin(angle/2), axis[2]*np.sin(angle/2)])  # Convert axis-angle representation to quaternion

    return q



if __name__ == '__main__':

    App = FreeCAD
    filename_export = 'ifc_beams'
    App.newDocument(filename_export)
    fcdocexport = App.getDocument(filename_export)
    config=os.getenv('APPDATA')+f'/FreeCad/config.json'
    with open(config, 'r') as f:
        path = json.load(f)

    path=path['File Path']
    # read json -> get range of bones
    ids = [i for i in range(1, 2)]
    segments = [f'intermediate_bone_{i}.obj' for i in ids]
    # 1 get polygon corners
    # hardcode_path as FC macro works on different directories and I don't care

    #ToDo: Change path to path of input 
    j=0
    with open(path+f'/data/Sample_Json/beam_sample.json', 'r') as f:
        raw_beam_data = json.load(f)['Beams']
        for iter in raw_beam_data:
           if j>0:
               break

           #1 getting cornerpoints
           polygon_corners=iter['ListofConers']

           # 3 set up FreeCAD "file"
		   # maybe all in one document?
           filename_beam = 'beam_skeleton'
           App.newDocument(filename_beam)
           fcdoc = App.getDocument(filename_beam)
           body=fcdoc.addObject('PartDesign::Body', 'Body')

           fcdoc.recompute()

           #   4 sketch bone line
           fcdoc.getObject('Body').newObject('Sketcher::SketchObject', 'line_path')
           line_1 = fcdoc.getObject('line_path')
           line_1.Support = (fcdoc.getObject('XY_Plane'), [''])
           line_1.MapMode = 'FlatFace'
           vector=np.asarray([iter["End"][i]-iter["Start"][i] for i in range(3)])
           length=np.linalg.norm(vector)
           
           line_1.addGeometry(Part.LineSegment(
              App.Vector(0, 0, 0),
              App.Vector(length,0,0)),
              False
           )
           fcdoc.recompute()

           #   5 sketch polygon, move to where it should be # TODO: fine tune placement wrt axis? (fine tune axis or this?)
           
           fcdoc.getObject('Body').newObject('Sketcher::SketchObject', 'cross_section')
           polygon = fcdoc.getObject('cross_section')
           polygon.Support = (fcdoc.getObject('YZ_Plane'), [''])
           polygon.MapMode = 'FlatFace'

           polygon_edges = []
           for i in range(len(iter['ListofConers'])):
               if i != len(iter['ListofConers'])-1:
                   polygon_edges.append((i, i + 1))
               else:
                   polygon_edges.append((i, 0))

           print(polygon_edges)

           for edge in polygon_edges:
               polygon.addGeometry(Part.LineSegment(
               App.Vector(iter['ListofConers'][edge[0]][0], iter['ListofConers'][edge[0]][1], 0),
               App.Vector(iter['ListofConers'][edge[1]][0], iter['ListofConers'][edge[1]][1], 0)),
               False
           )

           fcdoc.recompute()


           #   6 sweep
           fcdoc.addObject('Part::Sweep', 'beam')
           sweep = fcdoc.getObject('beam')
           sweep.Sections = polygon
           sweep.Spine = line_1
           sweep.Solid = True
           sweep.Frenet = False
		   
           # 7 Rotation

           rotation_all=np.matmul(iter["PCA_rot"],iter["PCB_rot"])

           # testing
       
           sweep.Placement = App.Placement(App.Matrix(
               rotation_all[0][0], rotation_all[0][1], rotation_all[0][2], 0,
               rotation_all[1][0], rotation_all[1][1], rotation_all[1][2], 0,
               rotation_all[2][0], rotation_all[2][1], rotation_all[2][2], 0,
               0, 0, 0, 1
           ))
           fcdoc.recompute()

           # 7.2 translate
           sweep.Placement.move(App.Vector(
               iter["Start"][0],
               iter["Start"][1],
               iter["Start"][2]
           ))
           fcdoc.recompute()

           
            #	8 save beam into IFC Export list
           App.setActiveDocument(filename_export)
           placement=sweep.Placement
           crosssection=fcdocexport.copyObject(polygon, True)
           beam = Arch.makeStructure(crosssection,height=length)
           #move beam because extrusion is into negative axes
           yawpitchroll=placement.Rotation.toEuler()
           yaw=np.deg2rad(yawpitchroll[2])
           pitch=np.deg2rad(yawpitchroll[1])
           roll=np.deg2rad(yawpitchroll[0])

           Rx = np.array([[1, 0, 0],
                           [0, np.cos(pitch), -np.sin(pitch)],
                           [0, np.sin(pitch), np.cos(pitch)]])

           Ry = np.array([[np.cos(yaw), 0, np.sin(yaw)],
                           [0, 1, 0],
                           [-np.sin(yaw), 0, np.cos(yaw)]])

           Rz = np.array([[np.cos(roll), -np.sin(roll), 0],
                           [np.sin(roll), np.cos(roll), 0],
                           [0, 0, 1]])

           R = Rz.dot(Ry.dot(Rx))
           # Calculate the direction vector
           d = R.dot(np.array([1, 0, 0]))
           beam.Placement=placement
           beam.Profile="Crosssection"
           #shift beam to match start point of sweep extrution
           beam.Placement.Base.x=placement.Base.x+(length*d[0])
           beam.Placement.Base.y=placement.Base.y+length*d[1]
           beam.Placement.Base.z=placement.Base.z+length*d[2]
           beam.IfcType='Beam'
           Draft.autogroup(beam)
           fcdocexport.recompute()
           App.setActiveDocument(filename_beam)



            # 9 export to obj
           __objs__ = []
           __objs__.append(fcdoc.getObject('beam'))
           Mesh.export(__objs__, path+f'/data/out/0_skeleton/beam_bone_{j}.obj')
           j=j+1
           del __objs__
           
           # 9 clean up
           #App.closeDocument(filename_beam)



	# Pipe stuff

	# get range from json file lenght pipes
    ids = [i for i in range(1, 30)]
    segments = [f'intermediate_bone_{i}.obj' for i in ids]
	# ToDo: change path to path in json with pipe folder
	
	
    path_hack = f'C:/Users/ga25mal/PyCharmProjects/reconstruct/data/out_pipe/sweep_pipe.txt'

    piperuns = []
    with open(path_hack, 'r') as f:
        # read in json for pipes
        objlines = f.readlines()
        # read x y z as floats
        piperun_0 = [[float(i) for i in objlines[0].split(' ')[1:7]],
                     [float(i) for i in objlines[1].split(' ')[1:7]],
                     [float(i) for i in objlines[2].split(' ')[1:7]]]
        piperuns.append(piperun_0)
        piperun_1 = [[float(i) for i in objlines[3].split(' ')[1:7]]]
        piperuns.append(piperun_1)
        piperun_2 = [[float(i) for i in objlines[4].split(' ')[1:7]]]
        piperuns.append(piperun_2)

    radius = 17.7 /100  # sorry.
    # 3 set up FreeCAD "file"
    filename_pipe = 'pipe_skeleton'
    App.newDocument(filename_pipe)
    fcdoc = App.getDocument(filename_pipe)
    fcdoc.addObject('PartDesign::Body', 'Body')
    fcdoc.recompute()
	
	#foreach pipe go throught segements
    for i, piperun in enumerate(piperuns):
        print(i)
        # 4 draw wire in Draft
        pl = FreeCAD.Placement()
        # pl.Rotation.Q = (0.0, 0.0, 0.0, 1.0)
        pl.Base = FreeCAD.Vector(piperun[0][0], piperun[0][1], piperun[0][2])
        if len(piperun) == 1:
            points = [
                FreeCAD.Vector(piperun[0][0], piperun[0][1], piperun[0][2]),
                FreeCAD.Vector(piperun[0][3], piperun[0][4], piperun[0][5])]
            print(points)
        if len(piperun) == 3:  # again, I am very sorry for this hack
            points = [
                FreeCAD.Vector(piperun[0][0], piperun[0][1], piperun[0][2]),
                FreeCAD.Vector(piperun[0][3], piperun[0][4], piperun[0][5]),
                FreeCAD.Vector(piperun[1][0], piperun[1][1], piperun[1][2]),
                FreeCAD.Vector(piperun[1][3], piperun[1][4], piperun[1][5]),
                FreeCAD.Vector(piperun[2][0], piperun[2][1], piperun[2][2]),
                FreeCAD.Vector(piperun[2][3], piperun[2][4], piperun[2][5])]
        line = Draft.make_wire(points, placement=pl, closed=False, face=True, support=None)
        Draft.autogroup(line)
        FreeCAD.ActiveDocument.recompute()

        pl = FreeCAD.Placement()

        # calculate rotation matrix to rotate z axis with vector
        vector = np.array(points[1] - points[0])

        a = np.array([0, 0, 1])
        b = vector / np.linalg.norm(vector)
        v = np.cross(a, b)
        c = np.dot(a, b)
        s = np.linalg.norm(v)
        kmat = np.array([[0, -v[2], v[1]],
                         [v[2], 0, -v[0]],
                         [-v[1], v[0], 0]])
        rotmat = np.eye(3) + kmat + kmat.dot(kmat) * ((1 - c) / (s ** 2))
        # rotmat from numpy to FreeCAD
        rotmat = App.Matrix(rotmat[0][0], rotmat[0][1], rotmat[0][2], 0,
                            rotmat[1][0], rotmat[1][1], rotmat[1][2], 0,
                            rotmat[2][0], rotmat[2][1], rotmat[2][2], 0,
                            0, 0, 0, 1)

        pl.Rotation.Matrix = rotmat

        pl.Base = FreeCAD.Vector(piperun[0][0], piperun[0][1], piperun[0][2])
        circle = Draft.makeCircle(radius=radius, placement=pl, face=True, support=None)
        Draft.autogroup(circle)
        FreeCAD.ActiveDocument.recompute()
        #
        # 5 make pipe
        App.getDocument(filename).addObject('Part::Sweep', f'Pipe_{i}')
        App.getDocument(filename).ActiveObject.Sections = [circle, ]
        App.getDocument(filename).ActiveObject.Spine = line
        App.getDocument(filename).ActiveObject.Solid = True
        App.getDocument(filename).ActiveObject.Frenet = False
        App.getDocument(filename).ActiveObject.Transition = u"Round corner"


	# export IFC
    beam_skeleton=App.getDocument(filename_beam)
    pipe_skeleton=App.getDocument(filename_pipe)
    filename_export = 'ifc_beams'
    App.newDocument(filename_export)
    fcdoc = App.getDocument(filename_export)
    #get all beams
    for obj in beam_skeleton.Objects:
        if obj.TypeId=='Part::Sweep':
            placement=obj.Placement
            crosssection=fcdoc.copyObject(obj.Sections[0], True)
            length=obj.Spine[0].Geometry[0].length()
            beam = Arch.makeStructure(crosssection,height=length)
            #move beam because extrusion is into negative axes
            yawpitchroll=placement.Rotation.toEuler()
            yaw=np.deg2rad(yawpitchroll[2])
            pitch=np.deg2rad(yawpitchroll[1])
            roll=np.deg2rad(yawpitchroll[0])

            Rx = np.array([[1, 0, 0],
                           [0, np.cos(pitch), -np.sin(pitch)],
                           [0, np.sin(pitch), np.cos(pitch)]])

            Ry = np.array([[np.cos(yaw), 0, np.sin(yaw)],
                           [0, 1, 0],
                           [-np.sin(yaw), 0, np.cos(yaw)]])

            Rz = np.array([[np.cos(roll), -np.sin(roll), 0],
                           [np.sin(roll), np.cos(roll), 0],
                           [0, 0, 1]])

            R = Rz.dot(Ry.dot(Rx))

            # Calculate the direction vector
            dot(np.array([1, 0, 0]))
            placement=placement
            profile="Crosssection"
            ifcType='Beam'
            autogroup(beam)
            recompute()
             
    for obj in pipe_skeleton.Objects:
        if obj.TypeId=='Part::Sweep':
            placement=obj.Placement
            crosssection=fcdoc.copyObject(obj.Sections[0], True)
            line=fcdoc.copyObject(obj.Spine[0],True)
            pipe = Arch.makePipe(crosssection)
            Draft.autogroup(pipe)
            pipe = Arch.makePipe(line)
            Draft.autogroup(pipe)
            pipe.Diameter=radius*2


    print('PyCharm says hi and congrats for running the whole macro without errors!')


